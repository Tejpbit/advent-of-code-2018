
from concurrent.futures import ThreadPoolExecutor
from functools import reduce
# f = open("05.data")

# lines = f.readlines()

# polymerstring = lines[0]


from threading import Lock
import _thread


def asd(acc, future):
    (prev, newStr) = acc
    if future.islower() and future.capitalize() != prev:
        return (future, newStr+prev)
    elif future.isupper() and future.lower() != prev:
        return (future, newStr+prev)
    return ('', newStr)


def reduceMax(polymerstring):
    (last, q) = reduce(asd, polymerstring, ('', ""))
    q = q + last
    prevQ = polymerstring
    while len(prevQ) != len(q):
        # print(q)
        prevQ = q
        (last, q) = reduce(asd, q, ('', ""))
        q = q+last
    return q

# print(q)
# print(len(q))


def runReduceMaxNamed(polymer, name):
    global sem
    global results
    res = reduceMax(polymer)
    return (name, res)


reducedPolymer = "lXOFifLmfbmvsxtzTKBkillsEJgfvBMNmEyksjICnCNYOxbWZFSMWVLiwixTlQEQrleuDLjvBNkDCqwmZrqhoQnvWEoNwAQEWUnJfpzfYVWJqrmSYnqhNyWxIYjiMjdQJsVLEXuFxyhPWLQAPongydxxzARkbFkiEQhKmGYnhwNXVCEAYghwTCIRdQayAVoUKeCKydncaNUTuQLQzdjqgZawIODzhsKDScnZkUAGKjNwcPhpRwYILMjQKKPDJSfLakkVhOiKvoKzCYfNiqnoLYcqlsnzdLrYJbQDMABiJiTCHBAYLjLmgDoicLqSatHNRvechhJRxnaIULdmVVobgsxgrMCzYtqGSYKovJVOmFHmpVshAhEPXKyirOibqyMuJCREOTpguNLxMGSAuHFWiyJyOrLYQDZJhyMNOisYGNrPVzYmmuQAwmCRPXkpzYROQrXkRAKmXMgPFykowlnOhZAFRgoBwmSdxgrvvvkFZpSULqAqKOYunEIHSijAfEBvDLglcylsRDhWcYIReUttCsisAvEgEtcjvHEbEDVznZXmCbuRBNFjeugZmRzRBXsVrXIrHxELFsgWvKcNtpLWCufgQMacyHUYBtKCeULEczzXiFZLhCLoYuWYYctgbgNbrLqNFXJzLiaOHIRemSblnqlMymABEUxDmFJImTVgRmlRtaREBzcZDheMJHamGSOvgpGYSTpfeenfhJLLWSicuGduBGCuxunDvFPcZRLIHxpywKpuWvWEEHXaLnCvpUBrmtXihmuXFQUZBkwRxPsPdCVFxAqYRIoPmGjOHwkDgPsOOXfkcfUnduVPkFWNcUhxbLOIdvnCAGKqORUzdZApgVaKEcmazSZoSlgeMWyvvgMEgkWDZMCezoLhejcLBWVjCsxnkFRAuxStpRQchpqSQgyxMuqzAHypgeIAyoxcqXYJHvpbZVJRRTSCdANiJBXaulsJbkNjmivjUSMhTrBnsVaKGiVqYtAykIjGCsfKDqjzmqcRSVNKSPtWqcxpNPiLEHTNrAXudVNiGWDLxQbSqPMHuFOZCiOzmZDTIsTjYvvXvRaoXHBGXGIbWBMpKZFULuDvbpVJAFUcAnBNhLjtFobzHAkGaojSYupVpnyVwfSqxtMZrPcmrKlOcBOLaOWEAyKgBlcwmrcoRAmWUJSbwvxVzqjaljHGaGhqlQCwtJZhTjMWNkXOetNhEtBwNiHeaOuxrCQcZabUjMXfQSbKcdyCuWBBsVunRjEHAfIxWkDDwyixidCiJlUAmsKVghscnPQvMMbvorNgzohwvtOyBCBOWmESVuMAmAPZiqtmiqrFeKfrytnBpgsDtYlwPzumJhysmJGhTGYEiLsXMeDURzLmSBBLOkxDBHSakpNKdysvkqAhXfVOTkGwfNuOalEAPtzwqxUmaEuRZmpeqByXDflXbiYYOLKDASTZEispBpHrNYpAENpoHcoYufNdgJBHsyMvTMVNOcMayjnqSVcHsukDFLedgvwVMrwJdbfPOLgOsrsqVchkeKyTugYXfRkySGklhZPaFMKnQzDZWoQxhWUgylKafqOcuDhVKGduORoKoChpYxMPYtdasXHYDSupAlBJFMfcIlYkLhaNSYfhwkQhtKfWTQMJVAbwlrIqBGkJyPATpYYtDmYIDAgQTYmBHOtbTfDgSXVBjGZaNGvgvGzqHmPdxKDizIaiCkRtBaSTwXwYGwYTBPojPFhuOvRcJElZwpcYNtMwyseBoQZZflvupSScJuWDtrwmqoEQwEvwzcqtpLoapyNdzSenwXUFOMbSfbvenVKREQIJREGvaaNYmYUOzNEFvNYLmuRATEXNPAGwfnaYmhYqRAsgrUXqLfGySqbSzBSbmKxqrqhppyejxQuCAbREhfoHEXpnFlXMxrmEUFboKIgrMeWXgsVGVpzMIQRftptDNDwOQdiizBDHUqVhEmUWLgvyAMdGbsEqMSjFEzQglIqurxgVHltXsubKfWAJAmwBuMahrujoEQyaKzAxMTWcAeoospZWrTrdVGJhVJXkNtKSYdqUelqtwvvkxaTJPLraqFzmATEcbuFvHCWFBVrUHeBabaalyqudLJRQfkcFKpXQxHlRWyDOeoqZQWaUWxrEdwxCXnvegDMPSzIaLbmrZbLsPfUHlOfrhVSuyuriEuEuOYqDHoXqnlqfnVDIvJrwvaSVuxfaeMlodLmuXfLqkhFtrPJniFyespnAxGxqLRxqEbGzhSpQRQZyEmbQIqLWPHEYsngnbIDLAAPxzarJfdtDhhLUtvktgETVVtRmBiDpNPlBSyeSgstjDLdxWVRYkBKSHHyfvoQEaGKSJJxLASaoWZKgPETUfMAGFDUkFbgMeSzCPcXSUplNLrUbcIaBIUzPIPzobfsxMOOKAxjWfThTxlJxPcJlrCzcJKeANjvupZVTXmzaIsBZAIurQlhjMOkQVUzVyhLqwguxyhNWukHcnytNPvAyhxWYPIWTmvBZLYFaWrghSLuMSNTxucRGsdFwxOrXnUsyFOtFNrlzDYfJIfUemPPskgkmuhCFKAobtMqvjTMIWbjnSYklSWCtXJJnWfviWqFwitqVHlcFGScDvklUdkSTVtAgjBhSlPoxyJvuSSXVyjPiPXrTfhRsLuHosGCwvpEOyzifIpWSedRLWsglCZDSBMEvORyQeYMylplWPLhsFRNPqXCBfwwkLQePXbqfZUoVpunYPTVWypVPOcXHzhszLqNedvWjRUMgtJPiuXmBKJeWeNViCnbZPKPgzFCCOYrvJxKFNjttzRfSWgCwzWNoUBcUvBzOYExmvrgHplIFjRbIswOffpcLEDNBrgznAqEKcwDrOiVywdslcGLQlgPKQRkwEodGzgwJUZIOqjZnmvWvzugdKUpFhZIbarGmQBMdYThfxqTaWQsfNIvqCIdVyFdhEQzgxYLCdtRsQBGnjhglHJfKAgHGQlVMhffiCWzlZGviuewAElZjKOWkGBIGQLqwITXwGSwdJuCPlDGemazphNEkiLZZWnctLWCIGhRYOhddlfxiUSMajjNmFubHuOgBTTXAYzLfhCVFemCqKtwXwwucipEitNeSAgrNOPSTdqHQNibotqwQCKIavjQbmGMSaghviTxjyBxpKrGkWOycsoojbWxqEdRzfbMaoHjMEmteibXpIzIOdEZhwubaMUavIAXYHOMOaICkBZSAXkbbMWxDtfzVEImGrvkwDmmAXIPzGuVxDQHiORcmpRIySYhYzcpyJcYaZnyWqfOMIGqaxBaFxtnHXYPPwaaypNeWWrPoyLNEcixdVLIJyRpfvAVCKUGmWkhxvLSUShEstXbHVqmsruxgMcTTvOIcKfXSWOesdbvHVIPoPtyRdkqCmydqdWziuqIukOUwtWVcMgdqfRanpKupUKdgOlRywNxYCXYxVTAdyVcqIIvuaqupRkpTrTGpKjaOJpUADsNHErmCygigYZuLZQkuZxSunzdCgNtQuqrlIfdBPTmHUNRoQGIzMBsOGjRFJPTiDAmCFkjERptKtwbPblncccodWDJUszHMpmoNVhTDOyxSGvEzBYKeOyyqysProSzsgZRdhfsHxyOLxRVdciVynurgZilCsuHZooXpAewlINJvJqkRRuVoGJHgwngIJnaFsiFacBKmBJqNWtxmiSAbIqdyynHAQCBOgLZAKMAwDaxIznoFJpabURJYVGEYGRyRnurTjIYKHkrtUHxsYUfjisZImEiHAJnEpVRHoyEGJwMPHSBenOhJoydCiigbZSlYAClVPXaLrTFjwtltDliRuuYVdYtUQaHBwiJmLiZxnVfBXHNWhSbjjAjUsndyXCCsAHmrJHzHevmixWXUkJLwxpZrhbZLNdEauXLnsjaeBnwGzmTSNgkFyJTvUWUcnQfceWGrNxQNknXVaXDJkiTuVEsEwsiEykgtptDnUYlBuMBLjkMKZjKCzgiGMvowLnPijzBgDHVGxWNDSrbJoTJnDsgSEkDAteGmoWbtwQFphtuqptOPzfjDFajuQxeQJucPDksKCSJsThXQZcgUrblhvzUzggHDUFODnksxZvTUytQccsXpMXqrgZHlCRsFRGAhrfWKHfojYdNNBuEwqqfNOYsgWQKQJmBoiyJaDbDCBicFtzCbGpUUbEvlIEIKuqgOVZKfPOOBpGsJyeKEiVyuSmvTqNTdkBpBLEWWPxCKslZgLkJayoUzOqrTvNWnSLJUyGNLQiFpJGstNMXTUJPfNfGhxvtnBrgZhYkUtaVhIGtAGUrlUGefdvvWuoBGzcNoARUYXNfYDarTTfjXTyLNspUxDHMOKvmvmgnmOtEHBTmnGIEuEuDEMTmLwxgOPAITSPNbmmoVsYCippdehtsjPjgvKuKbfPTwkNvhlJVEzGdhhEisQLDhaJQXrshOGrXEjEtbsERyBaSvGKfhLrseWnJMbESKIrKZpIhvTAGVTkNBHDjXYjPjtCjPildTuLvSQsXsOAYnMDcVCEYjovcHxkduGydPNefxzntBQAQXvrqeRzAZpAKptWDEqRxpnDfpXdKETQxpiXqFRaKrUHVKMdrhZdyaEYlnkGyBlZKYGfpEsyWLkgrZZFgivJgbPdsArmzkPjOyEHNLULtEBDyqJaWUBDWGHnMAJvjnzPOJMouOjVJQXBdVDFxjSVwGyKhPRaRHqXDDGNyVYjCmoctwUZQltgXBmxhfbJuIpqRaTCgXGxSEgAYsBlguSmtdPMMqrslyXwuVTmxdbhpNMQRjveJQQKhnGRfifpDsTTAruNDYfhKoDFFQKMefkmzVTHSZjIHXQOrlfViiWSzchsLSzQkHaUWbyzgBiUJCsjsiYsLaPrOAmeQabwAIIEXULCGTvbdeMvAAkuJkpstLgHgIGwCKfdVPrBnkmeYEWxWzGseLrlESgZwXweyEMKNbRpvDFkcWgiGhGlTSPKjUKaaVmEDBVtgcluxeiiaWBAqEMaoRpAlSyISJScjuIbGZYBwuAhKqZslSHCZswIIvFLRoqxhiJzshtvZMKFEmkqffdOkHFydnURattSdPFIFrgNHkqqjEVJrqmnPHBDXMtvUWxYLSRQmmpDTMsUGLbSyaGesXgxGctArQPiUjBFHXMbxGTLqzuWTCOMcJyvYngddxQhrArpHkYgWvsJXfdvDbxqjvJoUOmjopZNJVjamNhgwdbuwAjQYdbeTlulnheYoJpKZMRaSDpBGjVIGfzzRGKlwYSePFgykzLbYgKNLyeAYDzHRDmkvhuRkArfQxIPXqtekDxPFdNPXrQedwTPkaPzaZrEQRVxqaqbTNZXFEnpDYgUDKXhCVOJyecvCdmNyaoSxSqsVlUtDLIpJcTJpJyxJdhbnKtvgatVHiPzkRikseBmjNwESRlHFkgVsAbYreSBTeJexRgoHSRxqjAHdlqSIeHHDgZevjLHVnKWtpFBkUkVGJpJSTHEDPPIcySvOMMBnpstiapoGXWlMtmedUeUeigNMtbheToMNGMVMVkomhdXuPSnlYtxJFttRAdyFnxyuraOnCZgbOUwVVDFEguLRugaTgiHvATuKyHzGRbNTVXHgFnFpjutxmnTSgjPfIqlngYujlsNwnVtRQoZuOYAjKlGzLSkcXpwwelbPbKDtnQtVMsUYvIekEYjSgPboopFkzvoGQUkieiLVeBuuPgBcZTfCIbcdBdAjYIObMjqkqwGSyonFQQWeUbnnDyJOFhkwFRHagrfSrcLhzGRQxmPxSCCqTYutVzXSKNdofudhGGZuZVHLBRuGCzqxHtSjsckSKdpCUjqEXqUJAfdJFZpoTPQUTHPfqWTBwOMgETadKesGSdNjtOjBRsdnwXgvhdGbZJIpNlWOVmgIGZckJzkmKJlbmUbLyuNdTPTGKYeISWeSevUtIKjdxAvxNKnqXnRgwECFqNCuwuVtjYfKGnstMZgWNbEAJSNlxUAeDnlzBHRzPXWljKuxwXIMVEhZhjRMhaSccxYDNSuJaJJBsHwnhxbFvNXzIlMjIWbhAquTyDvyUUrILdTLTWJftRlAxpvLcayLszBGIIcDYOjHoNEbshpmWjgeYOhrvPeNjahIeMizSIJFuySXhuTRKhkyiJtRUNrYrgyegvyjruBAPjfONZiXAdWamkazlGobcqahNYYDQiBasIMXTwnQjbMkbCAfISfANjiGNWGhjgOvUrrKQjVjniLWEaPxOOzhUScLIzGRUNYvICDvrXloYXhSFHDrzGSZsORpSYQYYoEkybZeVgsXYodtHvnOMPmhZSujdwDOCCCNLBpBWTkTPreJKfcMadItpjfrJgoSbmZigqOrnuhMtpbDFiLRQUqTnGcDZNUsXzUKqzlUzyGIGYcMRehnSdauPjoAJkPgtRtPKrPUQAUViiQCvYDatvXyxcyXnWYrLoGDkuPUkPNArFQDGmCvwTWuoKUiQUIZwDQDYModOcQKDrYTpOpivhVBDSEowsxFkCioVttCmGXURSMQvhBxTSeHsuslVXHKwMgukcvaVFPrYjilvDXICenlYOpRwwEnPYAAWppyxhNTXfAbXAQgimoFQwYNzAyCjYPCZyHysYirPMCroIhqdXvUgZpixaMMdWKVRgMievZFTdXwmBBKxaszbKciAomohyxaiVAumABUWHzeDoiZiPxBIETMemJhOAmBFZrDeQXwBJOOSCYowKgRkPXbYJXtIVHGAsmgMBqJVAikcqWQTOBInqhQDtsponRGasEnTIePICUWWxWTkQcMEfvcHFlZyaxttbGoUhBUfMnJJAmsuIXFLDDHoyrHgicwlTCNwzzlIKenHPZAMEgdLpcUjDWsgWxtiWQlqgibgKwokJzLeaWEUIVgzLZwcIFFHmvLqghGakFjhLGHJNgbqSrTDclyXGZqeHDfYvDicQVinFSqwAtQXFHtyDmbqMgRABizHfPukDGUZVwVMNzJQoizujWGZgDOeWKrqkpGLqlgCLSDWYvIoRdWCkeQaNZGRbndelCPFFoWSiBrJfiLPhGRVMXeyoZbVuCbuOnwZWcGwsFrZTTJnfkXjVRyoccfZGpkpzBNcIvnEwEjkbMxUIpjTGmurJwVDEnQlZSHZhxCopvPYwvtpyNUPvOuzFQBxpEqlKWWFbcxQpnrfSHlpwLPLYmyEqYroVembsdzcLGSwlrDEswPiFIZYoePVWcgSOhUlSrHFtRxpIpJYvxssUVjYXOpLsHbJGaTvtsKDuLKVdCsgfCLhvQTIWfQwIVFwNjjxTcwsLKysNJBwimtJVQmTBOakfcHUMKGKSppMEuFijFydZLRnfTofYSuNxRoXWfDSgrCUXtnsmUlsHGRwAfylzbVMtwipywXHYaVpnTYNChKUwnHYXUGWQlHYvZuvqKomJHLqRUiazbSiAZMxtvzPUVJnaEkjCZcRLjCpXjLXtHtFwJXakoomXSFBOZpipZuibAiCBuRlnLPusxCpcZsEmGBfKudfgamFutepGkzwOAsalXjjskgAeqOVFYhhskbKyrvwXDldJTSGsEYsbLpnPdIbMrTvvteGTKVTulHHdTDFjRAZXpaaldiBNGNSyehpwlQiqBMeYzqrqPsHZgBeQXrlQXgXaNPSEYfINjpRTfHKQlFxUMlDOLmEAFXUvsAVWRjVidvNFQLNQxOhdQyoUeUeIRUYUsvHRFoLhuFpSlBzRMBlAiZspmdGEVNxcXWDeRXwuAwqzQOEoYwrLhXqxPkfCKFqrjlDUQYLAABAbEhuRvbfwchVfUBCetaMZfQARlpjtAXKVVWTQLEuQDyskTnKxjvHjgvDRtRwzPSOOEaCwtmXaZkAYqeOJURHAmUbWMajawFkBUSxTLhvGXRUQiLGqZefJsmQeSBgDmaYVGlwuMeHvQuhdbZIIDqoWdndTPTFrqimZPvgvSGxwEmRGikOBfueMRXmxLfNPxehOFHerBacUqXJEYPPHQRQXkMBsbZsBQsYgFlQxuRGSarQyHMyANFWgapnxetarUMlynVfenZouyMynAAVgerjiqerkvNEVBFsBmofuxWNEsZDnYPAOlPTQCZWVeWqeOQMWRTdwUjCssPUVLFzzqObESYWmTnyCPWzLejCrVoUHfpJOpbtyWgyWxWtsAbTrKcIAiZIdkXDpMhQZgVGVgnAzgJbvxsGdFtBTohbMytqGadiyMdTyyPtapYjKgbQiRLWBavjmqtwFkTHqKWHFysnAHlKyLiCFmfjbLaPUsdyhxSADTypmXyPHcOkOroUDgkvHdUCoQFAkLYGuwHXqOwzdZqNkmfApzHLKgsYKrFxyGUtYkEKHCvQSRSoGlopFBDjWRmvWVGDElfdKUShCvsQNJYAmConvmtVmYShbjGDnFUyOChOPneaPynRhPbPSIeztsadkloyyIBxLFdxYbQEPMzrUeAMuXQWZTpaeLAoUnFWgKtovFxHaQKVSYDknPKAshbdXKolbbsMlZrudEmxSlIeygtHgjMSYHjMUZpWLyTdSGPbNTYRFkEfRQIMTQIzpaMamUvseMwobcbYoTVWHOZGnROVBmmVqpNCSHGvkSMauLjIcDIXIYWddKwXiFaheJrNUvSbbwUcYDCkBsqFxmJuBAzCqcRXUoAEhInWbTeHnTEoxKnwmJtHzjTWcqLQHgAghJLAJQZvXVWBsjuwMarOCRMWCLbGkYaewoAlobCoLkRMCpRzmTXQsFWvYNPvPUysJOAgKahZBOfTJlHnbNaCufajvPBVdUlufzkPmbwBigxgbhxOArVxVVyJtSitdzMZoIczofRUhmpQsBqXldwgInvDUxaRnthelIpnPXCQwTpsknvsrCQMZJQdkFScgJiKYaTyQvIgkAvSNbRtHmsuJVIMJnKBjSLUAxbjInaDcstrrjvzBPVhjyxQCXOYaiEGPYhaZQUmXYGqsQPHCqrPTsXUarfKNXScJvwblCJEHlOZEcmzdwKGemGVVYwmEGLsOzsZAMCekAvGPazDZuroQkgacNVDiolBXHuCnwfKpvUDNuFCKFxooSpGdKWhoJgMpOiryQaXfvcDpSpXrWKbzuqfxUMHIxTMRbuPVcNlAxheewVwUPkWYPXhilrzCpfVdNUXUcgbUDgUCIswlljHFNEEFPtsygPGVosgMAhjmEHdzCZberATrLMrGvtMijfMdXuebaMYmLQNLBsMErihoAIlZjxfnQlRBnGBGTCyywUyOlcHlzfIxZZCeluEckTbyuhYCAmqGFUcwlPTnCkVwGSfleXhRixRvSxbrZrMzGUEJfnbrUBcMxzNZvdeBehVJCTeGeVaSIScTTuEriyCwHdrSLYCLGldVbeFaJIshieNUyokQaQlusPzfKVVVRGXDsMWbOGrfazHoNLWOKYfpGkarKxRqoryZPKxprcMWaqUMMyZvpRngySIonmYHjzdqylRoYjYIwfhUasgmXlnUGPtoercjUmYQBIoRIYkxpeHaHSvPMhfMovjVOkysgQTyZcmRGXSGBOvvMDluiANXrjHHCEVrnhTAsQlCIOdGMlJlyabhctIjIbamdqBjyRlDZNSLQCylONQInFycZkOVkIoHvKKAlFsjdpkkqJmliyWrPHpCWnJkgauKzNCsdkSHZdoiWAzGQJDZqlqUtunACNDYkcEkuOvaYAqDrictWHGyaecvxnWHNygMkHqeIKfBKraZXXDYGNOpaqlwpHYXfUxelvSjqDJmIJyiwYnHQNysMRQjwvyFZPFjNuweqaWnOewVNqOHQRzMWQcdKnbVJldUELRqeqLtXIWIlvwmsfzwBXoyncNciJSKYeMnmbVFGjeSLLIKbktZTXSVMBFMlFIfoxL"
threads = []


with ThreadPoolExecutor(max_workers=26) as executor:
    for c in "abcdefghijklmnopqrstuvwxyz":
        a = reducedPolymer.replace(c, "", -1)
        b = a.replace(c.capitalize(), "", -1)
        print(f'Removed {c}', "starting")
        th = [(f'Removed {c}', executor.submit(
            runReduceMaxNamed, b, f'Removed {c}'))]
        threads += th
    print(threads)
    for (name, th) in threads:
        res = th.result()
        print(res[0], len(res[1]))
